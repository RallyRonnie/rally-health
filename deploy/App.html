<!DOCTYPE html>
<html>
<head>
    <title>Health Check</title>
    <!--  (c) 2013 Rally Software Development Corp.  All Rights Reserved. -->
    <!--  Build Date: Sun Oct 06 2013 19:09:42 GMT-0700 (PDT) -->
    <script type="text/javascript" src="/apps/2.0rc1/sdk.js"></script>

    <script type="text/javascript">
        Rally.onReady(function() {
             
Ext.define('TSDescriptions', {
    singleton: true,
    defaultF: function(value,metaData,record,rowIndex,colIndex,store,view){
        return value;
    },
    get_description: function(column) {
        var me = this;
        
        var data_index = column;
        var data_name = null;
        if ( typeof(column) !== "string" ) {
            data_index = column.dataIndex;
        } else {
            column = {
                dataIndex: data_index,
                text: null
            }
        }
        
        if ( typeof this[data_index] == "string") {
            var tpl = new Ext.XTemplate( me[data_index] );
            
            return tpl.apply(column);
        } else {
            return data_name;
        }
    },
    health_churn: "<b>{text}</b> <br/><br/>A measure of the change in the iteration's scope.<br/><br/>" +
         "It is defined as the standard deviation of the total scheduled <br/>" +
         "into the sprint divided by the average daily total.",
                  
    health_churn_direction: "<b>{text}</b> is an indicator of the general direction of scope change.<br/><br/>" +
        "It is determined by examining every day's change from the day before and adding or subtracting <br/>" +
        "the delta to determine whether scope has been added more often than subtracted. (The first day of <br/>" +
        "the iteration is excluded from this calculation.)",
        
    number_of_days_in_sprint: "<b>{text}</b> represents the number of full days in the iteration <br/>" +
            "(Excluding weekends)",
    health_ratio_estimated: "<b>{text}</b><br/><br/>" +
        "<b>Description</b><br/><br/>" +
        "Represents the ratio of work items (stories and defects) that have estimates.<br/><br/>" +
        "<b>How it is calculated</b><br/><br/>" +
        "Divide the number of work items (stories and defects) in the iteration that have a plan <br/>" +
        "estimate that is not null by the total number of items in the iteration multiplied by 100. <br/><br/>" +
        "<b>Coaching Tip</b><br/><br/>" + 
        "If there is a very high percentage or stories without estimates, other measures will not <br/>" + 
        "be meaningful.  This is really only useful for the beginning of an iteration, and perhaps <br/>" + 
        "for an iteration in early flight, but not for an iteration that has ended.  The idea is to <br/>" + 
        "catch this early in an iteration so other charts/graphs etc are useful for teams.  A good <br/>" + 
        "practice is to have a ready backlog as and entrance criteria to an iteration planning session, <br/>" + 
        "a ready backlog means three things, sized, ranked, and stories are elaborated sufficiently with <br/>" + 
        "acceptance criteria to enable conversation and confirmation during planning.",
    health_end_acceptance_ratio: "<b>{text}</b> is the percentage of items that were accepted before<br/>" +
            "the iteration ended.",
    health_ratio_in_progress: "<b>{text}</b> represents the average of the daily percentages of items<br/>" +
            "marked as In Progress",
    health_half_accepted_ratio:"<b>{text}</b> represents the point in the iteration where at least 50%<br/>" +
            "of the scheduled items were accepted.  (If an accepted item rolls back in state, the search for a new<br/>" +
            "halfway mark restarts.)",
    health_end_incompletion_ratio:"<b>{text}</b>"

});
/*
 */
Ext.define('Rally.technicalservices.logger',{
    constructor: function(config){
        Ext.apply(this,config);
    },
    log: function(args){
        var output_args = [];
        if (arguments.length === 0 ) {
            window.console && console.log(arguments);
            return;
        }
        if (arguments.length === 1 ) {
            output_args = arguments;
        } else {
            var src_class = arguments[0];
            var class_name = "";
            if ( typeof(src_class) === "string" ) {
                class_name = src_class;
            } else if ( typeof src_class.getName === "function") { 
                class_name = src_class.getName();
            } else if (typeof src_class.self.getName === 'function'){
                class_name = src_class.self.getName();
            }
            //window.console && console.log(class_name,"--",message);
            output_args = Ext.Array.push(output_args,[class_name,"--"]);
            output_args = Ext.Array.push(output_args,Ext.Array.slice(arguments,1));
        }
        window.console && console.log.apply(console,output_args);
    }

});
/*
 * A simple collection of renderers by name.  Note that "this" is NOT this singleton
 * 
 */
 
 Ext.define('TSRenderers', {
    singleton: true,
    red: '#ff9999',
    yellow: '#ffffcc',
    green: '#ccffcc',
    health_green_limit: 0.91,
    defaultF: function(value,metaData,record,rowIndex,colIndex,store,view){
        return value;
    },
    estimateHealth: function(value,metaData) {
        
        if ( value < 0 ) {
            return " ";
        }
        var percent = parseInt( 100 * value, 10 );
        var color = TSRenderers.green;
        if ( value < TSRenderers.health_green_limit ) {
            color = TSRenderers.yellow;
        }
        if ( value < 0.61 ) {
            color = TSRenderers.red;
        }
        metaData.style = "background-color: " + color;
        return "<div style='text-align:center;background-color:" + color + "'>"+ percent + "%</div>";
    },
    inProgressHealth: function(value,metaData,record) {
        var color = TSRenderers.green;

        var percent = parseInt( 100 * value, 10 );
        if ( record.get('health_ratio_estimated') < TSRenderers.health_green_limit ) {
            color = '#D0D0D0';
        } else {
            if ( value < 0 ) {
                return " ";
            }
            if ( percent > 25 ) {
                color = TSRenderers.yellow;
            }
            if ( percent > 35 ) {
                color = TSRenderers.red;
            }
        }
        metaData.style = "background-color: " + color;
        return "<div style='text-align:center;background-color:" + color + "'>"+ percent + "%</div>";
    },
    halfAcceptedHealth: function(value,metaData,record) {
        if ( value < 0 ) {
            return " ";
        }
        var percent = parseInt( 100 * value, 10 );
        var text = percent + "%";
        
        var color = TSRenderers.green;
        if ( record.get('health_ratio_estimated') < TSRenderers.health_green_limit ) {
            color = '#D0D0D0';
        } else {
            if ( percent > 50 ) {
                color = TSRenderers.yellow;
            }
            if ( percent > 75 ) {
                color = TSRenderers.red;
            }

        }
            if ( percent === 200 ) {
                text = "Never";
            }
        metaData.style = "background-color: " + color;
        return "<div style='text-align:center;background-color:" + color + "'>"+ text + "</div>";
    },
    incompletionHealth: function(value,metaData,record) {
        if ( value < 0 ) {
            return " ";
        }
        var percent = parseInt( 100 * value, 10 );
        var text = percent + "%";
        
        var color = TSRenderers.green;
        if ( record.get('health_ratio_estimated') < TSRenderers.health_green_limit ) {
            color = '#D0D0D0';
        } else {
            if ( percent > 9 ) {
                color = TSRenderers.yellow;
            }
            if ( percent > 20 ) {
                color = TSRenderers.red;
            }
            if ( percent === 200 ) {
                color = "white";
                text = "No Data";
            }
        }
        metaData.style = "background-color: " + color;
        return "<div style='text-align:center;background-color:" + color + "'>"+ text + "</div>";
    },
    acceptanceHealth: function(value,metaData,record) {
        if ( value < 0 ) {
            return " ";
        }
        var percent = parseInt( 100 * value, 10 );
        var text = percent + "%";
        
        var color = TSRenderers.green;
        if ( record.get('health_ratio_estimated') < TSRenderers.health_green_limit ) {
            color = '#D0D0D0';
        } else {
            
            if ( percent < 91 ) {
                color = TSRenderers.yellow;
            }
            if ( percent < 50 ) {
                color = TSRenderers.red;
            }
            if ( percent === 200 ) {
                color = "white";
                text = "No Data";
            }
        }
        metaData.style = "background-color: " + color;
        return "<div style='text-align:center;background-color:" + color + "'>"+ text + "</div>";
    },
    churnHealth: function(value,metaData,record) {
        
        var text = "No data";
        var color = "white";
        
        if ( value >= 0 ) {
            var percent = parseInt( 100 * value, 10 );
            text = percent + "%";
        }
        
        if ( record.get('health_ratio_estimated') < TSRenderers.health_green_limit ) {
            color = '#D0D0D0';
        }
        metaData.style = "background-color: " + color;
        return "<div style='text-align:center;background-color:" + color + ";'>" + text + "</div>";
    },
    churnTaskHealth: function(value,metaData,record) {
        var text = "No data";
        var color = "white";
        if ( value >= 0 ) {
            var percent = parseInt( 100 * value, 10 );
            text = percent + "%";
        }
            
        if ( record.get('health_ratio_estimated') < TSRenderers.health_green_limit ) {
            color = '#D0D0D0';
        }
        metaData.style = "background-color: " + color;
        return "<div style='text-align:center;background-color:" + color + ";'>" + text + "</div>";
    },
    churnDirection: function(value,metaData,record) {
        var color = "white";
        var display_value = ".";
        if ( value === -2 ) {
            display_value = "No Data";
        } else if ( value < 0 ) { 
            display_value = "<img src='/slm/mashup/1.11/images/minus.gif' title='down'>";
        } else if ( value > 0 ) {
            display_value = "<img src='/slm/mashup/1.11/images/plus.gif' title='up'>";
        }
        if ( record.get('health_ratio_estimated') < TSRenderers.health_green_limit ) {
            color = '#D0D0D0';
        }
        metaData.style = "background-color: " + color;
        return "<div style='text-align:center;background-color:" + color + ";'>" + display_value + "</div>";
    },
    shortDate: function(value) {
        return Rally.util.DateTime.formatWithNoYearWithDefault(value);
    }
    
});
Ext.define('Rally.technicalservices.util.Utilities', {
    singleton: true,
    hashToArray: function(hash) {
        var result = [];
        for ( var key in hash ) {
            result.push(hash[key]);
        }
        return result;
    },
    /*
     * Given a hash of TS projects where the key is the object id of the project,
     * return an array of TS projects with their parent/child relationships wired up
     */
    structureProjects: function(structured_projects, add_root) {
        var me = this;
        var potential_root = Ext.create('Rally.technicalservices.ProjectModel',{
            Name: 'Workspace',
            ObjectID: null
        });
        
        for ( var pid in structured_projects ) {
            var child = structured_projects[pid];
            if ( child.get('parent_id') && structured_projects[child.get('parent_id')] ) {
                var parent = structured_projects[child.get('parent_id')];
                parent.addChild(child);
            } else if ( add_root ) {
                potential_root.addChild(child);
            }
        }
        
        var results = this.hashToArray(structured_projects);
        if ( add_root ) {
            results.unshift(potential_root);
        }
        return results
    },
    /*
     * Given a hash that represents an item with children, return
     * an array of the items with the items exploded (in order, top down (follow a branch then come back to next branch))
     * 
     * That is, order is parent 1, child 1a, child 1b, parent 2, child 2a
     */
    hashToOrderedArray: function(hash,child_field_name) {
        var me = this;
        var the_array = [hash];
        
        var kids = hash[child_field_name];
// add this back if we want the order to be parent 1, parent 2, child 1a, child 1b, child 2a
//        Ext.Array.each(kids, function(kid){
//            the_array.push(kid);
//        });
        
        Ext.Array.each(kids, function(kid){
            var kid_array = me.hashToOrderedArray(kid,child_field_name);
            the_array = Ext.Array.merge(the_array,kid_array);
        });
        
        return the_array;
    },
    /**
     * Given a hash with nested hashes of similar strucure (nested by field "children"), 
     * find the item in the hash 
     *   where the given field has the given value
     */
    getFromHashByField: function(hash,by_field_name,by_field_value){
        var me = this;
        var result = null;
        if (hash[by_field_name] == by_field_value) {
            return hash;
        }
        if ( hash.children ) {
            Ext.Array.each(hash.children,function(child){
                result = me.getFromHashByField(child,by_field_name,by_field_value);
                if (result) {
                    return false;
                }
            });
        }
        return result;
    },
    /** 
     * Given an array ot TSProjects, get one out of the array by its ID
     */
    getProjectById: function(project_array,object_id) {
        var result = null;
        var field_name = "ObjectID";
        Ext.Array.each(project_array, function(project) {
            if (project.get(field_name) == object_id) {
                result = project;
            }
        });
        return result;
    },
    daysBetween: function(begin_date_js,end_date_js,skip_weekends){
        var dDate1 = Ext.clone(begin_date_js).setHours(0,0,0,0);
        var dDate2 = Ext.clone(end_date_js).setHours(0,0,0,0);
        
        if ( dDate1 == dDate2 ) { return 0; }
        if (typeof dDate1 === "number") { dDate1 = new Date(dDate1); }
        if (typeof dDate2 === "number") { dDate2 = new Date(dDate2); }
            
        if ( !skip_weekends ) {
            return Math.abs( Rally.util.DateTime.getDifference(dDate1,dDate2,'day') );
        } else {
            // from the sOverflow
            var iWeeks, iDateDiff, iAdjust = 0;
            if (dDate2 < dDate1) 
            { 
                var x = dDate2;
                dDate2 = dDate1;
                dDate1 = x;
            }
            var iWeekday1 = dDate1.getDay(); // day of week
            var iWeekday2 = dDate2.getDay();
            iWeekday1 = (iWeekday1 == 0) ? 7 : iWeekday1; // change Sunday from 0 to 7
            iWeekday2 = (iWeekday2 == 0) ? 7 : iWeekday2;
            if ((iWeekday1 > 5) && (iWeekday2 > 5)) iAdjust = 1; // adjustment if both days on weekend
            iWeekday1 = (iWeekday1 > 5) ? 5 : iWeekday1; // only count weekdays
            iWeekday2 = (iWeekday2 > 5) ? 5 : iWeekday2;
    
            // calculate differnece in weeks (1000mS * 60sec * 60min * 24hrs * 7 days = 604800000)
            iWeeks = Math.floor((dDate2.getTime() - dDate1.getTime()) / 604800000)
    
            if (iWeekday1 <= iWeekday2) {
              iDateDiff = (iWeeks * 5) + (iWeekday2 - iWeekday1)
            } else {
              iDateDiff = ((iWeeks + 1) * 5) - (iWeekday1 - iWeekday2)
            }
    
            iDateDiff -= iAdjust // take into account both days on weekend
    
            if ( iDateDiff < 0 ) { iDateDiff = 0; }
            return (iDateDiff); 
        }
    }
});
var useName = function(value,record) {
    if ( record.get('Name') ) {
        return record.get('Name');
    } 
    return null;
};

var useObjectID = function(value,record) {
    if ( record.get('ObjectID') ) {
        return record.get('ObjectID');
    } 
    return 0;
};

var convertMetric = function(value,record) {
    value = value.toLowerCase();
    if ( value !== "count" ) {
        value = "estimate";
    }
    return value;
};
Ext.define('Rally.technicalservices.ProjectModel',{
    extend: 'Ext.data.Model',
    require: ['Rally.technicalservices.util.Utilities'],
    fields: [
        {name:'ObjectID', type: 'int'},
        {name:'Name',type:'string'},
        {name:'parent_id',type:'int'},
        {name:'id',type:'int',convert:useObjectID},
        {name:'text',type:'string',convert:useName},
        {name:'metric',type:'string',defaultValue:'estimate',convert:convertMetric}, /* by count or by estimate */
        /* values from the one associated iteration */
        {name:'iteration_name',type:'string',defaultValue:''},
        {name:'iteration_end_date',type:'auto'},
        {name:'iteration_start_date',type:'auto'},
        {name:'number_of_days_in_sprint',type:'int',defaultValue:-1},
        /*  following values are calculated */
        {name:'child_count',type:'int',defaultValue:0},
        {name:'health_ratio_estimated',type:'float',defaultValue:0},
        {name:'health_ratio_in_progress',type:'float',defaultValue:0},
        {name:'health_half_accepted_ratio',type:'float',defaultValue:2},
        {name:'health_end_incompletion_ratio',type:'float',defaultValue:2},
        {name:'health_end_acceptance_ratio',type:'float',defaultValue:2},
        {name:'health_churn',type:'float',defaultValue:-2},
        {name:'health_churn_direction',type:'float',defaultValue:-2},
        {name:'health_churn_task',type:'float',defaultValue:-2}
    ],
    hasMany:[{model:'Rally.technicalservices.ProjectModel', name:'children'}],
    associations: [
        {type:'belongsTo',model:'Rally.technicalservices.ProjectModel', setterName: 'setParent', getterName:'getParent', primaryKey:'ObjectID',foreignKey:'parent_id'}
    ],
    addChild: function(child) {
        this.set('health_ratio_estimated',-1);
        this.set('health_ratio_in_progress',-1);
        this.set('health_half_accepted_ratio',-1);
        this.set('health_end_incompletion_ratio',-1);
        this.set('health_end_acceptance_ratio',-1);

        if ( child.get('parent_id') !== this.get('ObjectID') ) {
            child.setParent(this.get('ObjectID'));
        }
        if ( this.get('children') ) {
            var kids = this.get('children');
            kids.push(child);
            this.set('children',kids);
        } else {
            this.set('children',[child]);
        }
        this.set('child_count',this.get('children').length);
    },
    addIteration: function(iteration) {
        if (typeof(iteration.get) == "function" ) {
            iteration = iteration.getData();
        }

        this.set('iteration_name',iteration.Name);
        this.set('iteration_start_date',iteration.StartDate);
        this.set('iteration_end_date',iteration.EndDate);
        this.set('number_of_days_in_sprint',Rally.technicalservices.util.Utilities.daysBetween(iteration.StartDate,iteration.EndDate,true)+1);
    },
    /**
     * override because we just want the kids without going through a load process
     */
    getAssociatedData: function(){
        var children = [];
        var kids = this.get('children');
        Ext.Array.each( kids, function(kid) {
            children.push(kid.getData(true));
        });
        return { 'children': children };
    },

    /**
     * Given an array of iteration cumulative flow objects, calculate a few health metrics
     */
    setIterationCumulativeFlowData: function(icfd){
        var me = this;
        this.daily_plan_estimate_totals = {};
        this.daily_task_estimate_totals = {};
        
        if ( this.get('child_count')  > 0 ) {
            this.set('health_ratio_in_progress',-1);
        } else {
            Ext.Array.each(icfd, function(cf) {
                var card_date = cf.get('CreationDate');
                // eliminate weekends
                if ( !card_date || ( card_date.getDay() > 0 && card_date.getDay() < 6 )) {
                    // eliminate outside the sprint dates if we have them
                    if ( me._isInsideSprint(card_date) ) {
                        var card_plan_estimate = cf.get('CardEstimateTotal');
                        var card_state = cf.get('CardState');
                        var card_task_estimate = cf.get('TaskEstimateTotal');
                        
                        if ( !me.daily_plan_estimate_totals.All ) { me.daily_plan_estimate_totals.All = {}; }
                        if ( !me.daily_plan_estimate_totals[card_state]){ me.daily_plan_estimate_totals[card_state] = {} }
                        if ( !me.daily_task_estimate_totals.All ) { me.daily_task_estimate_totals.All = {}; }
                        if ( !me.daily_task_estimate_totals[card_state]){ me.daily_task_estimate_totals[card_state] = {} }
                                          
                        if ( !me.daily_plan_estimate_totals.All[card_date] ) { me.daily_plan_estimate_totals.All[card_date] = 0; }
                        if ( !me.daily_plan_estimate_totals[card_state][card_date] ) { me.daily_plan_estimate_totals[card_state][card_date] = 0; }
                        if ( !me.daily_task_estimate_totals.All[card_date] ) { me.daily_task_estimate_totals.All[card_date] = 0; }
                        if ( !me.daily_task_estimate_totals[card_state][card_date] ) { me.daily_task_estimate_totals[card_state][card_date] = 0; }
                        
                        me.daily_plan_estimate_totals.All[card_date] += card_plan_estimate;
                        me.daily_plan_estimate_totals[card_state][card_date] += card_plan_estimate;
                        me.daily_task_estimate_totals.All[card_date] += card_task_estimate;
                        me.daily_task_estimate_totals[card_state][card_date] += card_task_estimate;
                    }
                }
            });
            
            this._setAverageInProgress();
            this._setHalfAcceptanceRatio();
            this._setAcceptanceRatio();
            this._setIncompletionRatio();
            this._setChurn();
            this._setTaskChurn();
        }
    },
    _setChurn: function(){
        var me = this;
        var all_hash = this.getDailyPlanEstimateTotalByState();
        if ( all_hash ) {
            var daily_plan_estimate_totals = [];
            for ( var card_date in all_hash ) {
                daily_plan_estimate_totals.push(all_hash[card_date]);
            }
            var standard_deviation = this._getStandardDeviation(daily_plan_estimate_totals);
            var deviation_ratio = Ext.util.Format.number(standard_deviation/Ext.Array.mean(daily_plan_estimate_totals),"0.00");
            this.set('health_churn',deviation_ratio);
            this.set('health_churn_direction',me._getChurnDirection(daily_plan_estimate_totals));
        }
    },
    // Adjusts for Rally "zero'ing" the card creation time for cumulative flow cards
    // Example:
    // Actual card creation time: 2013-08-11T23:59:59
    // WSAPI-Reported card creation time: 2013-08-11T00:00:00
    // Adjusted card creation time: 2013-08-11T23:59:59
    _adjustCardTime: function(card_date) {
        if ( typeof(card_date.getTime) != "function") {
            card_date = new Date(card_date);
        }
        var adjusted_date = Rally.util.DateTime.add(card_date, "hour", 23);
        adjusted_date = Rally.util.DateTime.add(adjusted_date, "minute", 59);
        adjusted_date = Rally.util.DateTime.add(adjusted_date, "second", 59);
        return adjusted_date;
    },
    
    _setTaskChurn: function(){
        var me = this;
        var all_hash = this.getDailyTaskEstimateTotalByState();
        var iteration_end = this.get('iteration_end_date');
        
        if ( all_hash ) {
            var previous_value = null;
            var last_day_value = null;
            Ext.Array.each( Ext.Object.getKeys(all_hash), function(card_date) {
                card_date_string = Rally.util.DateTime.toIsoString(me._adjustCardTime(card_date));
                iteration_date_string = Rally.util.DateTime.toIsoString(iteration_end);
                
                if ( card_date_string == iteration_date_string )  {
                    last_day_value = all_hash[card_date];
                } else {
                    previous_value = all_hash[card_date];
                }
            });

            if ( last_day_value && previous_value && previous_value > 0 ) {
                var task_churn = Ext.util.Format.number(Math.abs(( previous_value - last_day_value )/previous_value),"0.00");
                this.set('health_churn_task', task_churn );
            }
        }
    },
    /**
     * Given a hash of hashes structured as:
     * 
     * The outer hash key is state (plus "All")
     * The inner hash key is date (in JS date format)
     * The inner value is the sum of estimates for that day
     */
    _setAverageInProgress:function(){
        var all_hash = this.getDailyPlanEstimateTotalByState();
        var ip_hash = this.getDailyPlanEstimateTotalByState("In-Progress");

        if (!all_hash || !ip_hash) { 
            this.set('health_ratio_in_progress',0); 
        } else {
            var totals = [];

            for ( var card_date in all_hash ) {
                var day_total = all_hash[card_date];
                var day_ip = ip_hash[card_date] || 0;
                
                totals.push( day_ip/day_total );
            }
            this.set('health_ratio_in_progress',Ext.util.Format.number(Ext.Array.mean(totals),"0.00"));
        }
    },
    /**
     * Given a hash of hashes structured as:
     * 
     * The outer hash key is state (plus "All")
     * The inner hash key is date (in JS date format)
     * The inner value is the sum of estimates for that day
     */
    _setHalfAcceptanceRatio:function(){
        var all_hash = this.getDailyPlanEstimateTotalByState();
        var accepted_hash = this.getDailyPlanEstimateTotalByState("Accepted");

        if (!all_hash || !accepted_hash) { 
            this.set('health_half_accepted_ratio',0); 
        } else {
            var day_index = -1;
            var day_counter = 0;
            for ( var card_date in all_hash ) {
                    day_counter++;
                    
                    var day_total = all_hash[card_date];
                    var day_accepted = accepted_hash[card_date] || 0;
                    
                    if ( day_accepted/day_total >= 0.5 && day_index === -1 ) {
                        day_index = day_counter;
                    } else if ( day_accepted/day_total < 0.5 && day_index > -1 ) {
                        // if we slipped back to under 50%
                        day_index = -1;
                    }
            }
            var ratio = 2;
            if ( day_index > -1 ) {
                if ( this.get('number_of_days_in_sprint') > -1 ) {
                    day_counter = this.get('number_of_days_in_sprint');
                }

                ratio = Ext.util.Format.number(day_index/day_counter,"0.00");
            }
            this.set('health_half_accepted_ratio',ratio);
        }
    },
    /**
     * Given a hash of hashes structured as:
     * 
     * The outer hash key is state (plus "All")
     * The inner hash key is date (in JS date format)
     * The inner value is the sum of estimates for that day
     */
    _setIncompletionRatio:function(){
        var all_hash = this.getDailyPlanEstimateTotalByState();
        var accepted_hash = this.getDailyPlanEstimateTotalByState("Accepted");
        var completion_hash = this.getDailyPlanEstimateTotalByState("Completed");
        
        if (!all_hash) { 
            this.set('health_end_incompletion_ratio',0); 
        } else {
            var card_dates = Ext.Object.getKeys(all_hash);
            var last_date = card_dates.pop();
            
            var last_total = all_hash[last_date];
            var last_accepted = 0;
            var last_completed = 0;
            if ( accepted_hash ) {
                last_accepted = accepted_hash[last_date] || 0;
            }
            if ( completion_hash ) {
                last_completed = completion_hash[last_date] || 0;
            }
            var ratio = 1 - ( (last_completed+last_accepted)/last_total );
            ratio = Ext.util.Format.number(ratio,"0.00");
            
            this.set('health_end_incompletion_ratio',ratio);
        }
    },
    /**
     * Given a hash of hashes structured as:
     * 
     * The outer hash key is state (plus "All")
     * The inner hash key is date (in JS date format)
     * The inner value is the sum of estimates for that day
     */
    _setAcceptanceRatio:function(){
        var all_hash = this.getDailyPlanEstimateTotalByState();
        var accepted_hash = this.getDailyPlanEstimateTotalByState("Accepted");
        
        if (!all_hash) { 
            this.set('health_end_acceptance_ratio',0); 
        } else {
            var card_dates = Ext.Object.getKeys(all_hash);
            var last_date = card_dates.pop();
            
            var last_total = all_hash[last_date];
            var last_accepted = 0;
            var last_completed = 0;
            if ( accepted_hash ) {
                last_accepted = accepted_hash[last_date] || 0;
            }
            
            var ratio = last_accepted/last_total;
            ratio = Ext.util.Format.number(ratio,"0.00");
            
            this.set('health_end_acceptance_ratio',ratio);
        }
    },
    /*
     * Given a state, what are the total task estimate values in that state for each date?
     * 
     * return full total when no state provided
     */
    getDailyTaskEstimateTotalByState: function(state,type) {
        if ( !state ) { state = "All"; }
        return this.daily_task_estimate_totals[state];
    },
    /*
     * Given a state, what are the total plan estimate values in that state for each date?
     * 
     * return full total when no state provided
     */
    getDailyPlanEstimateTotalByState: function(state,type) {
        if ( !state ) { state = "All"; }
        return this.daily_plan_estimate_totals[state];
    },
    /**
     * Given an array of artifacts (stories and defects), calculate some health metrics
     * 
     */
    setIterationArtifacts: function(artifacts){
        // parents don't roll up.  set to -1
        if ( this.get('child_count')  > 0 ) {
            this.set('health_ratio_estimated',-1);
        } else {
            var plan_estimate_total = 0;
            var count_of_estimated_artifacts = 0;
            
            Ext.Array.each(artifacts,function(artifact){
                var plan_estimate = artifact.get('PlanEstimate') || 0;
                plan_estimate_total += plan_estimate;
                if ( plan_estimate > 0 ) {
                    count_of_estimated_artifacts++;
                }
            });
            
            if ( artifacts.length > 0 ) {
                this.set('health_ratio_estimated',(count_of_estimated_artifacts/artifacts.length));
            }
        }
    },
    /**
     * Go through the array of day totals.  If there are
     * more going up than down, return 1, if more going down than
     * going up, return -1 
     */
    _getChurnDirection: function(day_totals) {
        var variance = 0;
        var last_value = 0;
        Ext.Array.each(day_totals, function(day_total,index){
            if ( index > 0 ) {
                variance = variance + ( day_total - last_value );
            }
            last_value = day_total;
            
        });
        
        return  variance && variance / Math.abs(variance);
    },
    /**
     * 
     * @param {} an_array  an array of numbers
     * 
     * returns the standard deviation
     */
    _getStandardDeviation: function(an_array){
        var mean = Ext.Array.mean(an_array);
        var numerator = 0;
        
        Ext.Array.each(an_array,function(item){
            numerator += ( mean - item ) * ( mean - item ) ;
        });
        
        var deviation = Math.sqrt(numerator / an_array.length);
        
        return deviation;
    },
    _isInsideSprint: function(card_date) {
        
        if ( this.get('iteration_end_date') && this.get('iteration_start_date') ) {
            var end = this.get('iteration_end_date');
            var start = this.get('iteration_start_date');
            return ( card_date <= end && card_date >= start );
        } else {
            return true;
        }
    },
    resetHealth: function() {
        if ( this.get('child_count')  > 0 ) {
            this.set('health_ratio_estimated',-1);
            this.set('health_ratio_in_progress',-1);
            this.set('health_half_accepted_ratio',-1);
            this.set('health_end_incompletion_ratio',-1);
            this.set('health_end_acceptance_ratio',-1);
        } else {
            this.set('health_ratio_estimated',0);
            this.set('health_ratio_in_progress',0);
            this.set('health_half_accepted_ratio',2);
            this.set('health_end_incompletion_ratio',2);
            this.set('health_end_acceptance_ratio',2);
        }
        this.set('health_churn',-2);
        this.set('health_churn_direction',-2);
        this.set('health_churn_task',-2);
    }
});
/*
 * A store that holds projects
 * (DOES NOT update project information, must be passed projects)
 */
Ext.define('Rally.technicalservices.ProjectStore',{
    extend: 'Rally.data.custom.Store',
    alias: 'store.projectree',
    model: 'Rally.technicalservices.ProjectModel',
    
    getRecords: function() {
        var items = [];
        this.each(function(storeItem) {
            items.push(storeItem);
        });
        return items;
    },
    
    getModelType: function() {
        return this.model.getName();
    }
});
Ext.define('CustomApp', {
    extend: 'Rally.app.App',
    componentCls: 'app',
    logger: new Rally.technicalservices.logger(),
    items: [ 
        { xtype:'container',itemId:'selector_box', padding: 5, layout: { type:'hbox'} }, 
        { xtype:'container', itemId:'grid_box', padding: 5 }
    ],
    _project_store: null,
    launch: function() {
        this.number_of_iterations = 3;
        this._addIterationCountSelector();
    },
    _addIterationCountSelector: function() {
        
        var counter_store = Ext.create('Rally.data.custom.Store',{
            data: [
                {
                    Name: 3
                },
                {
                    Name: 4
                },
                {
                    Name: 5
                },
                {
                    Name: 6
                },
                {
                    Name: 7
                },
                {
                    Name: 8
                },
                {
                    Name: 9
                },
                {
                    Name: 10
                },
                {
                    Name: 15
                },
                {
                    Name: 20
                }
            ]
        });
        var me = this;
        
        this.down('#selector_box').add({
            xtype: 'rallycombobox',
            fieldLabel: 'Number of Iterations',
            store: counter_store,
            displayField: 'Name',
            valueField: 'Name',
            width: 150,
            labelWidth: 100,
            value: me.number_of_iterations,
            listeners: {
                scope: this,
                ready: function(cb) {
                    me.logger.log(this,"ready",cb.getValue());
                    me.number_of_iterations = cb.getValue();
                    me._getIterations();
                },
                change: function(cb) {
                    me.logger.log(this,"change",cb.getValue());
                    me.number_of_iterations = cb.getValue();
                    me._getIterations();
                }
            }
        });
    },
    _getIterations: function() {
        var me = this;
        var number_of_iterations = this.number_of_iterations;
        var today_iso = Rally.util.DateTime.toIsoString(new Date());
        Ext.create('Rally.data.WsapiDataStore',{
            model:'Iteration',
            limit: number_of_iterations,
            pageSize: number_of_iterations,
            autoLoad: true,
            sorters: [{ property: 'EndDate', direction: 'DESC' }],
            filters: [{ property: 'EndDate', operator: '<', value: today_iso}],
            context: { projectScopeDown: false },
            listeners: {
                scope: this,
                load: function(store,iterations){
                    this.logger.log(this,iterations);
                    var ts_iterations = this._makeTSIterationArray(iterations);
                    this.logger.log(this,ts_iterations);
                    
                    this._project_store = Ext.create('Rally.technicalservices.ProjectStore',{
                        data: ts_iterations
                    });
                    
                    this._project_store.load(function() { me._processData(); } );
                }
            }
        });
    },
    _getProjects: function() {
        var me = this;
        this._projects = [];
        var selected_project_oid = this.getContext().getProject().ObjectID;

        Ext.create('Rally.data.WsapiDataStore',{
            model:'Project',
            limit: 'Infinity',
            autoLoad: true,
            listeners: {
                load: function(store,projects) {
                    var ts_project_hash = this._makeTSProjectHash(projects);
                    var ts_project_array = Rally.technicalservices.util.Utilities.structureProjects(ts_project_hash,true);
                    var ts_selected_project = Rally.technicalservices.util.Utilities.getProjectById(ts_project_array,selected_project_oid);
                    var ts_selected_projects = Rally.technicalservices.util.Utilities.hashToOrderedArray(ts_selected_project.getData(true),"children");

                    this._project_store = Ext.create('Rally.technicalservices.ProjectStore',{
                        data: ts_selected_projects
                    });
                    
                    this._project_store.load(function() { me._processData(); } );
                },
                scope: this
            }
        });
        
    },
    _addIterationSelector: function() {
        this.iteration_selector = this.down("#selector_box").add({
            xtype:'rallyiterationcombobox',
            listeners: {
                ready: function(cb){
                    this.logger.log(this,"ready");
                    if ( cb.getValue() ) {
                        this.getEl().mask("Loading");
                        this._updateIterationDisplay(cb);
                    } else {
                        this.logger.log(this,"No iteration selected");
                    }
                },
                change: function(cb,new_value,old_value){
                    this.logger.log(this,"change");
                    if ( cb.getValue() ) {
                        this.getEl().mask("Loading");
                        this._updateIterationDisplay(cb);
                    } else {
                        this.logger.log(this,"No iteration selected");
                    }
                },
                scope: this
            }
        });
        this.down('#selector_box').add({
            xtype:'container',
            itemId: 'iteration_range_box',
            tpl: [
                "{start_date} - {end_date} ({number_of_days} days)",
                '<tpl if="day_counter &gt; -1">',
                "<br/>This is day {day_counter} of the iteration",
                '</tpl>'
            ]
        });
    },
    _updateIterationDisplay: function(combobox) {
        this._selected_timebox = combobox.getRecord();
        var start_date = this._selected_timebox.get(combobox.getStartDateField());
        var end_date = this._selected_timebox.get(combobox.getEndDateField());
        var day_counter = -1;
        var today = new Date();
        if ( today >= start_date && today <= end_date ) {
            day_counter = Rally.technicalservices.util.Utilities.daysBetween(today,start_date,"true") + 1;
        }
        var number_of_days_in_sprint = Rally.technicalservices.util.Utilities.daysBetween(end_date,start_date,"true") + 1;
        
        this._selected_timebox.set('number_of_days_in_sprint',number_of_days_in_sprint);
        
        var formatted_start_date = Rally.util.DateTime.formatWithNoYearWithDefault(start_date);
        var formatted_end_date = Rally.util.DateTime.formatWithNoYearWithDefault(end_date);
        
        this.down('#iteration_range_box').update({
            start_date:formatted_start_date,
            end_date:formatted_end_date,
            day_counter:day_counter,
            number_of_days: number_of_days_in_sprint
        });
        
        this._processData();
    },
    _processData:function() {
        this.logger.log(this,"Processing Data");
        var me = this;
        if ( me._project_store ) {
            me._return_counter = 0; // the calls for iterations are asynchronous, so we need to count returns
            var projects = me._project_store.getRecords();
            
            Ext.Array.each(projects,function(project){
                project.resetHealth();
                //project.set('number_of_days_in_sprint',me._selected_timebox.get('number_of_days_in_sprint'));
                me._setArtifactHealth(project.get('iteration_name'),project);
                me._setCumulativeHealth(project.get('iteration_name'),project);
            });

            this._makeGrid(this._project_store);
        }
    },
    /*
     * (health related to data we can get from the cumulative flow records)
     * 
     * Given the name of an iteration and a TSProject, go get the iteration cumulative flow records
     * 
     */
    _setCumulativeHealth:function(iteration_name,project){
        var me = this;
        
        // we've switched to the "project" object have the id of the iteration
        var iteration_oid = project.get('ObjectID');
        Ext.create('Rally.data.WsapiDataStore',{
            model:'IterationCumulativeFlowData',
            autoLoad: true,
            filters: [{property:'IterationObjectID',value:iteration_oid}],
            fetch: ['CardCount','CardEstimateTotal','CreationDate','IterationObjectID','TaskEstimateTotal','CardToDoTotal','CardState'],
            listeners: {
                load: function(store,records){
                    if ( records.length === 0 ) {
                        me.logger.log(this, project.get('Name'), "No cumulative flow data found for project ");
                    } else {
                        me.logger.log(this,project.get('Name'),'CFD',records);
                        project.setIterationCumulativeFlowData(records);
                    }
                }
            }
        });
              
    },
    /*
     * (health related to data we can get from the artifacts themselves)
     * Given the name of an iteration and a TSProject, go get the iteration stories and defects
     * associated with an iteration with that name, then let the TSProject calculate various metrics
     */
    _setArtifactHealth: function(iteration_name,project) {
        this.logger.log(this,"_setArtifactHealth",iteration_name,project);
        var me = this;
        
        var artifacts = []; // have to get both stories and defects
        var filters = [
            {property:'Iteration.Name',value:iteration_name}
        ];
        
        var fetch = ['ObjectID','PlanEstimate','ScheduleState'];
        
        Ext.create('Rally.data.WsapiDataStore',{
            model: 'UserStory',
            autoLoad: true,
            filters: filters,
            fetch: fetch,
            listeners: {
                load: function(store,records){
                    artifacts = records;
                    Ext.create('Rally.data.WsapiDataStore',{
                        model:'Defect',
                        autoLoad: true,
                        filters: filters,
                        fetch: fetch,
                        listeners: {
                            load: function(store,records){
                                artifacts = Ext.Array.push(artifacts,records);
                                me.logger.log(this,project.get('Name'),artifacts.length);
                                project.setIterationArtifacts(artifacts);
                            }
                        }
                    });
                }
            }
        });
        
    },
    // given a set of Rally project objects, turn them into TS projects
    // the key of the hash is the project's ObjectID
    _makeTSProjectHash: function(projects) {
        var structured_projects = {}; // key is oid
        
        // change into our version of the project model
        // and put into a hash so we can find them easily for adding children
        Ext.Array.each(projects,function(project){
            var parent = project.get('Parent');
            var parent_oid = null;
            
            if ( parent ) { 
                parent_oid = parent.ObjectID; 
            }
            structured_projects[project.get('ObjectID')] = Ext.create('Rally.technicalservices.ProjectModel',{
                ObjectID: project.get('ObjectID'),
                parent_id: parent_oid,
                Name: project.get('Name')
            });
        });
        return structured_projects;
    },
    // given a set of Rally iteration objects, turn them into TS projects
    // the key of the hash is the project's ObjectID
    _makeTSIterationArray: function(iterations) {
        var iteration_array = []; // key is oid
        
        // change into our version of the project model
        Ext.Array.each(iterations,function(iteration){
            
            var iteration_row = Ext.create('Rally.technicalservices.ProjectModel',{
                ObjectID: iteration.get('ObjectID'),
                Name: iteration.get('Name')
            });
            
            iteration_row.addIteration(iteration);
            iteration_array.push(iteration_row);
            
        });
        
        return iteration_array;
    },
    /*
     * Given an array of projects, make a grid
     */
    _makeGrid: function(store) {
        
        if ( this.grid ) { this.grid.destroy(); }
        
        var column_listeners = {
            scope: this,
            headerclick: function( ct, column, evt, target_element, eOpts ) {
                if (this.popover){this.popover.destroy();}
                this.popover = Ext.create('Rally.ui.popover.Popover',{
                    target: Ext.get(target_element),
                    items: [{
                        cls: 'ts_popover_description',
                        xtype:'container',
                        html:TSDescriptions.get_description(column)
                    }]
                });
                this.popover.show();
            }
        };
        this.grid = Ext.create('Rally.ui.grid.Grid',{
            store: store,
            height: 400,
            sortableColumns: false,
            columnCfgs: [
                {text:'Iteration',dataIndex:'iteration_name',flex: 2},
                {text:'Start Date',dataIndex:'iteration_start_date',renderer:TSRenderers.shortDate},
                {text:'End Date',dataIndex:'iteration_end_date',renderer:TSRenderers.shortDate},
                {text:'# Days',dataIndex:'number_of_days_in_sprint',listeners: column_listeners},
                {text:'Estimation Ratio (Current)',dataIndex:'health_ratio_estimated',renderer: TSRenderers.estimateHealth,listeners: column_listeners},
                {text:'Average Daily In-Progress',dataIndex:'health_ratio_in_progress',renderer: TSRenderers.inProgressHealth,listeners: column_listeners},
                {text:'50% Accepted Point', dataIndex:'health_half_accepted_ratio',renderer:TSRenderers.halfAcceptedHealth,listeners: column_listeners},
                {text:'Last Day Incompletion Ratio',dataIndex:'health_end_incompletion_ratio',renderer:TSRenderers.incompletionHealth,listeners: column_listeners},
                {text:'Last Day Acceptance Ratio',dataIndex:'health_end_acceptance_ratio',renderer:TSRenderers.acceptanceHealth,listeners: column_listeners},
                {text:'Churn',dataIndex:'health_churn',renderer:TSRenderers.churnHealth,listeners: column_listeners },
                {text:'Churn Direction',dataIndex:'health_churn_direction',renderer:TSRenderers.churnDirection,listeners: column_listeners},
                {text:'Task Churn',dataIndex:'health_churn_task',renderer:TSRenderers.churnTaskHealth,listeners: column_listeners}
                
            ]
        });
        this.down('#grid_box').add(this.grid);
        this.getEl().unmask();
    }
});
            
               Rally.launchApp('CustomApp', {
                   name: 'Health Check'
               });
        });
    </script>
    
    <style type="text/css">

.ts_popover_description {
    background-color: white;
    padding: 3px
}
    </style>

</head>
<body></body>
</html>